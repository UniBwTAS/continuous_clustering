#!/usr/bin/env python
PACKAGE = "streaming_clustering"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

gps = gen.add_group("Ground Point Segmentation", type="tab")
gps_columns = gps.add_group("Ground Point Segmentation in Columns")
gps_columns.add("first_ring_max_height_diff", double_t, 0, "first ring: max height difference compared to sensor's height to be classified as ground", 0.4, 0., 2.)
gps_columns.add("max_slope", double_t, 0, "max slope between points to be classified as ground", 0.2, 0, 2.)
gps_columns.add("flat_section_after_obstacle_min_points", int_t, 0, "min number of points required to detect a flat section after obstacle", 5, 0, 100)
gps_columns.add("flat_section_after_obstacle_min_length", double_t, 0, "min length required to detect a flat section after obstacle", 4., 0, 100.)
gps_rows = gen.add_group("Ground Point Segmentation in Rows")
gps_rows.add("max_z_distance_to_connection_line", double_t, 0, "max height difference to line defined by neighboring ground points", 0.05, 0, 2.)
gps_rows.add("max_xy_distance_to_connection_line", double_t, 0, "maximum distance to line defined by neighboring ground points", 1., 0, 10.)

c = gen.add_group("Clustering", type="tab")
c.add("max_distance", double_t, 0, "maximum distance of two points to be clustered together (a higher distance means a larger workload)", 0.7, 0.01, 5.)
c.add("max_steps_in_row", int_t, 0, "option to to reduce the workload: maximum number of steps searching for close enough neighbors in row", 20, 0, 3000)
c.add("max_steps_in_column", int_t, 0, "option to to reduce the workload: maximum number of steps searching for close enough neighbors in column", 20, 0, 3000)
c.add("stop_after_association_enabled", bool_t, 0, "option to to reduce the workload: whether to stop after the point was successfully associated (normally search is continued to search for other trees)", True)
c.add("stop_after_association_min_steps", int_t, 0, "option to to reduce the workload: this value (v) represents the minimum rectangle (width: v, height: v * 2 + 1) around current point to process even if point was already associated", 1, 0, 3000)
c.add("ignore_points_in_chessboard_pattern", bool_t, 0, "option to to reduce the workload: ignore every second obstacle point during clustering in a chessboard pattern (this works much better than ignoring every second row or column)", True)
c.add("ignore_points_with_too_big_inclination_angle_diff", bool_t, 0, "immediately ignore points which can't be associated to a lower point in the same column because of its combination of distance and inclination angle diff to lower laser are to high (the clustering result looks better, because these points to not result in separated clusters)", True)

exit(gen.generate(PACKAGE, "streaming_clustering_node", "StreamingClustering"))
